---
title: "Get started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include=FALSE}
knitr::opts_chunk$set(collapse  = TRUE,
                      comment   = "#>",
                      out.width = "100%",
                      dpi       = 150,
                      fig.align = "center")
```



```{r 'setup', echo=FALSE}
library("chessboard")
library("ggplot2")
library("patchwork")
```




```{r 'ggplot-theme', echo=FALSE}
## Custom ggplot2 theme ----
custom_theme <- function() {
  theme_light() + 
  theme(plot.title   = element_text(face = "bold", family = "serif", size = 18),
        plot.caption = element_text(face = "italic", family = "serif"),
        axis.title   = element_blank(),
        axis.text    = element_text(family = "serif"))
}
```


The aim of the package `chessboard` is to provide tools to work with **directed**
(asymmetric) and **undirected** (symmetrical) spatial (or not) **networks**. It
implements different methods to detect neighbors, all based on the chess game
(it goes beyond the rook and the queen available in many R packages) to create 
complex connectivity scenarios.


`chessboard` aims to easily create various network objects, including:

- **node list**, i.e. a list of all nodes of the network;
- **edge list**, i.e. a list of all edges (links) between pairs of nodes;
- **connectivity matrix**, i.e. a binary matrix of dimensions `n x n`, where 
`n` is the number of **nodes** (sampling units) indicating the presence (`1`) 
or the absence (`0`) of an **edge** (link) between pairs of nodes.


## Network properties

`chessboard` can handle spatial networks, but it does not explicitly use geographical
coordinates to find neighbors (it is not based on spatial distance). 
Instead, it identifies neighbors according to **node labels**
(i.e. the node position on a two-dimension chessboard) and a specific method 
(pawn, fool, rook, bishop, knight, queen, wizard, etc.) derived from the chess game.


```{r 'cb-network', eval=TRUE, fig.height=8, fig.width=5, echo=FALSE, fig.cap="Figure 1. Network as a chessboard", out.width='60%'}
sites <- expand.grid("transect" = 1:3, "quadrat" = 1:5)

nodes <- create_node_labels(data     = sites,
                            transect = "transect", 
                            quadrat  = "quadrat")

gg_chessboard(nodes)
```



The package `chessboard` is designed to work with two-dimensional networks (i.e. 
sampling on a regular grid), where one dimension is called **transect** 
and the other is called **quadrat**. By convention, the dimension **transect** 
corresponds to the x-axis, and the **quadrat** corresponds to the y-axis (Fig. 1). 

`chessboard` can also deal with one-dimensional network 
(either **transect-only** or **quadrat-only**).



The network can be undirected or directed. If the network is **directed**, it will 
have (by default) these two orientations:

- from bottom to top (along transect) for quadrats
- from left to right (along quadrat) for transects




## Neighbors detection



`chessboard` implements the following rules to detect neighbors and to create edges:

- the **degree** of neighborhood: the number of adjacent nodes that will be used
to create direct edges.

- the **orientation** of neighborhood: can neighbors be detected horizontally, 
vertically and/or diagonally?

- the **direction** of neighborhood: does the sampling has a main direction? 
This can be particularly relevant for directed networks (e.g. rivers).


## Workflow

The Figure 2 shows the general workflow and the main features of `chessboard`.


```{r echo = FALSE, out.width = "100%", fig.cap = "Figure 2. Workflow and main features of `chessboard`", fig.align = 'center'}
knitr::include_graphics("../man/figures/diagramme.png")
```



### Data

The package `chessboard` comes with a real-world example: a survey sampling 
along the French river _L'Adour_ (Fig. 3). _L'Adour_ is a river in southwestern 
France. It rises in the Pyrenees and flows into the Atlantic Ocean (Bay of Biscay). 
It's oriented from south-east (upstream) to north-west (downstream).


```{r 'map-adour-river', echo=FALSE, fig.height=9, fig.width=10, out.width='80%', fig.cap='Figure 3. Location of the French river L\'Adour'}
knitr::include_graphics("img/map-adour-river.png")
```


Along this river, a survey has been realized at **three** locations (Fig. 4).
At each location, a sampling has been conducted on a regular grid composed of 
**three** transects each of them composed of **five** quadrats.


```{r 'import-adour-river', echo=FALSE}
## Import the spatial layer of Adour river ----
path_to_file <- system.file("extdata", "adour_lambert93.gpkg", 
                            package = "chessboard")
adour_river  <- sf::st_read(path_to_file, quiet = TRUE)
```

```{r 'import-adour-sites', echo=FALSE}
## Import sites data ----
path_to_file <- system.file("extdata", "adour_survey_sampling.csv", 
                            package = "chessboard")
nodes  <- read.csv(path_to_file)

## Convert data.frame to sf object ----
nodes_sf <- sf::st_as_sf(nodes, coords = c("longitude", "latitude"),
                               crs = "epsg:2154")
```


```{r 'map-adour-sites', fig.height=9, fig.width=12, out.width='80%', echo=FALSE, fig.cap='Figure 4. Survey sampling along the river L\'Adour'}
ggplot() +
  geom_sf(data = adour_river, col = "steelblue") +
  geom_sf(data = nodes_sf, shape = 19, size = 2) +
  labs(caption = "RGF93 / Lambert-93 Projection") +
  custom_theme() +
  geom_segment(aes(x = 454180, xend = 440170, y = 6216290, yend = 6263320), 
               arrow = arrow(length = unit(0.75, 'cm'), type = 'closed'),
               linewidth = 2.25) +
  geom_text(aes(x = 334500, y = 6285000), label = "River", hjust = 0,
            color = "steelblue", fontface = "bold", size = 6, 
            family = "serif") +
  geom_text(aes(x = 414950, y = 6312200), label = "Location 3", hjust = -0.20,
            color = "black", fontface = "bold", size = 6, family = "serif") +
  geom_text(aes(x = 474655, y = 6236708), label = "Location 1", 
            color = "black", fontface = "bold", size = 6, family = "serif") +
  geom_text(aes(x = 467250, y = 6287620), label = "Location 2", 
            color = "black", fontface = "bold", size = 6, family = "serif")
```



The arrow in Fig. 4 indicates the direction of the river flow. This means that our 
sampling design is a **directed spatial network** (both inside a location and
between locations) where the main direction is from upstream to downstream. 

\

Let's import this dataset provided by `chessboard`.


```{r 'import-data', echo=TRUE}
# Import data ----
path_to_file <- system.file("extdata", "adour_survey_sampling.csv", 
                            package = "chessboard")

sampling  <- read.csv(path_to_file)

dim(sampling)
```

```{r 'head-of-data', echo=TRUE}
# First rows ----
head(sampling, 10)
```

```{r 'tail-of-data', echo=TRUE}
# Last rows ----
tail(sampling, 10)
```

This `data.frame` contains the following columns: 

- `location`: the identifier of the location (`numeric`)
- `transect`: the identifier of the transect (`numeric`)
- `quadrat`: the identifier of the quadrat (`numeric`)
- `longitude`: the longitude of the site (**node**) defined in the [RGF93 / Lambert-93](https://epsg.io/2154) projection
- `latitude`: the latitude of the site (**node**) defined in the [RGF93 / Lambert-93](https://epsg.io/2154) projection


**N.B.** The column `location` is optional if the survey has been conducted at one single location.
If the network has one dimension, one of the columns `transect` and `quadrat` can
be omitted. If the survey is not spatial, the columns `longitude` and `latitude` can be omitted.




### Node labels

When working with `chessboard`, the **first step** is to create node
labels with the function `create_node_labels()`.

\

But first, let's reduce the size of data by selecting the first location.


```{r 'select-data'}
# Select the first location ----
sampling <- sampling[sampling$"location" == 1, ]

dim(sampling)
```

\

Let's create node labels with the function `create_node_labels()`.

```{r 'create-nodes-labels'}
# Create node labels ----
nodes <- create_node_labels(data     = sampling,
                            location = "location",
                            transect = "transect",
                            quadrat  = "quadrat")

nodes
```


Node labels are a combination of the transect and the quadrat identifiers. They must be **unique**.

\

We can visualize this sampling on a Cartesian referential, i.e. non-spatial, where
the x-axis corresponds to **transects** and the y-axis represents the **quadrats**
(Fig. 5). This new referential is called a chessboard.




```{r 'plot-sampling-units', fig.height=8, fig.width=5, echo=TRUE, out.width='60%', fig.cap='Figure 5. Sampling survey as a chessboard'}
# Visualize chessboard ----
gg_chessboard(nodes)
```


\

The function `get_node_list()` can be used to extract and order the node list.

```{r 'get-node-labels'}
# Extract node labels ----
get_node_list(nodes)
```

### Neighbors detection

...


### Edge list

- Creation
- Combination
- Visualization


### Connectivity matrix

- Creation
- Combination
- Visualization




\


## Edges list



The creation of a list of edges (links) between nodes (sampling units) is based 
on the detection of neighbors. The function `create_edge_list()` implements 
three neighborhood rules:

1. **Degree of neighborhood** (argument `degree`): the number of adjacent 
nodes that will be used to create **direct** edges. If `degree = 1`, 
only nodes directly adjacent to the focal node will be considered as 
neighbors.
2. **Orientation of neighborhood** (argument `method`): can neighbors be 
detecting horizontally and/or vertically and/or diagonally? The package 
`chessboard` implements all possible orientations derived from the chess 
game.
3. **Direction of neighborhood** (arguments `directed` and `reverse`): does 
the sampling design has a direction? If so, the network 
will be considered as **directed** and the direction will follow the order 
of node labels in both axes of the grid.


\


Different methods have implemented to define neighborhood (argument `method` 
of the function `create_edge_list()`). These methods
are named `'pawn'`, `'rook'`, `'bishop'`, `'queen'`, etc. A complete list of
available methods is available at: 
[https://frbcesab.github.io/chessboard/reference/index.html#detect-neighbors](https://frbcesab.github.io/chessboard/reference/index.html#detect-neighbors)


\


Before using the function `create_edge_list()`, users can explore these different
methods by calling the functions `pawn()`, `rook()`, `bishop()`, `queen()`, etc.

Let's take a look of the neighborhood method `pawn()`.

```{r 'method-pawn'}
## Explore pawn method to find neighbors ----
neighbors_pawn <- pawn(nodes    = nodes, 
                       focus    = "2-3", 
                       degree   = 1, 
                       directed = FALSE, 
                       reverse  = FALSE)
neighbors_pawn
```

This function (and others) only works on a specific node (argument `focus`).


\


The package `chessboard` contains functions to visualize detected neighbors on a
chessboard: `gg_chessboard()` is used to plot a chessboard (dimensions defined by the
node list), `geom_node()` emphasizes the focus node (in red), and `geom_neighbors()` adds
the detected neighbors.


```{r 'nb-pawn', fig.height=8, fig.width=5, echo=FALSE, fig.cap="Figure 4. Detected neighbors (pawn method)", out.width='50%'}
gg_chessboard(nodes) +
  geom_node(nodes, focus = "2-3") +
  geom_neighbors(nodes, neighbors_pawn)
```


\


The Figure 5 shows the usage of the function `pawn()` (and others). 
This function can detect neighbors horizontally, i.e. among 
quadrats along a transect. User can change the default settings 
by increasing the degree of neighborhood (`degree = 4`, Fig. 5A),
by adding directionality (`directed = TRUE`, Fig. 5B), and 
by reversing the default directionality (`directed = TRUE` and `reverse = TRUE`, Fig. 5C).


```{r 'cb-pawn', fig.height=4.3, fig.width=12, echo=FALSE, fig.cap="Figure 5. Pawn movements", out.width='100%'}
demo_sites <- expand.grid("transect" = 1:9, "quadrat" = 1:9)

demo_nodes <- create_node_labels(data     = demo_sites,
                                 transect = "transect", 
                                 quadrat  = "quadrat")

demo_focus  <- "5-5"

pawn_1 <- 
  gg_chessboard(demo_nodes, "A. Undirected network", "") + 
  geom_node(demo_nodes, demo_focus) +
  geom_neighbors(demo_nodes, pawn(demo_nodes, demo_focus, degree = 4, 
                                  directed = FALSE, reverse = FALSE))

pawn_2 <- 
  gg_chessboard(demo_nodes, "B. Directed network", "") + 
  geom_node(demo_nodes, demo_focus) +
  geom_neighbors(demo_nodes, pawn(demo_nodes, demo_focus, degree = 4, 
                                  directed = TRUE, reverse = FALSE))

pawn_3 <- 
  gg_chessboard(demo_nodes, "C. Directed network (reverse)", "") + 
  geom_node(demo_nodes, demo_focus) +
  geom_neighbors(demo_nodes, pawn(demo_nodes, demo_focus, degree = 4, 
                                  directed = TRUE, reverse = TRUE))

(pawn_1 | pawn_2 | pawn_3)
```


\


Let's take another example with `method = "bishop"`. 
The function `bishop()` can detect neighbors diagonally. 
User can change the default settings 
by increasing the degree of neighborhood (`degree = 4`, Fig. 6A),
by adding directionality (`directed = TRUE`, Fig. 6B), and 
by reversing the default directionality (`directed = TRUE` and `reverse = TRUE`, Fig. 6C).


```{r 'cb-bishop', eval=TRUE, fig.height=4.3, fig.width=12, echo=FALSE, fig.cap="Figure 6. Bishop movements", out.width='100%'}
demo_sites <- expand.grid("transect" = 1:9, "quadrat" = 1:9)

demo_nodes <- create_node_labels(data     = demo_sites,
                                 transect = "transect", 
                                 quadrat  = "quadrat")

demo_focus  <- "5-5"

bishop_1 <- 
  gg_chessboard(demo_nodes, "A. Undirected network", "") + 
  geom_node(demo_nodes, demo_focus) +
  geom_neighbors(demo_nodes, bishop(demo_nodes, demo_focus, degree = 4, 
                                    directed = FALSE, reverse = FALSE))

bishop_2 <- 
  gg_chessboard(demo_nodes, "B. Directed network", "") + 
  geom_node(demo_nodes, demo_focus) +
  geom_neighbors(demo_nodes, bishop(demo_nodes, demo_focus, degree = 4, 
                                    directed = TRUE, reverse = FALSE))

bishop_3 <- 
  gg_chessboard(demo_nodes, "C. Directed network (reverse)", "") + 
  geom_node(demo_nodes, demo_focus) +
  geom_neighbors(demo_nodes, bishop(demo_nodes, demo_focus, degree = 4, 
                                    directed = TRUE, reverse = TRUE))

(bishop_1 | bishop_2 | bishop_3)
```


\

The vignette [Chess movements](https://frbcesab.github.io/chessboard/articles/movements.html) 
shows all possible movements implemented in `chessboard`.


\


Now, let's use the function `create_edge_list()` to create an edge list using the
method `'pawn'` with a degree `1` of neighborhood and in a directional way.


```{r 'create-edges-list-pawn'}
## Create edge list ----
adour_edges_pawn <- create_edge_list(nodes    = nodes, 
                                     method   = "pawn", 
                                     degree   = 1, 
                                     directed = TRUE,
                                     reverse  = FALSE,
                                     self     = FALSE)

adour_edges_pawn
```


\


It's possible to visualize these edges on a map, i.e. by using spatial coordinates.
First, we need to convert our sites into a spatial object (`POINT`).

```{r 'df-to-sf'}
## Convert sites to sf object ----
nodes_sf <- sf::st_as_sf(nodes, coords = c("longitude", "latitude"),
                               crs = "epsg:2154")

head(nodes_sf)
```


\


Now we can use the function `edges_to_sf()` to convert our edge list 
into a spatial object (`LINESTRING`).


```{r 'edges-list-to-sf'}
## Convert edge list to sf ----
adour_edges_pawn_sf <- edges_to_sf(edges = adour_edges_pawn, 
                                   sites = nodes_sf)

adour_edges_pawn_sf
```


\


We can now map our nodes and edges.

```{r 'map-edges-list-pawn', fig.height=8, fig.width=6.5, echo=TRUE, fig.cap="Figure 7. Edges list (pawn method)", out.width='80%'}
## Map of nodes and edges ----
ggplot(nodes_sf) +
  geom_sf(size = 12) +
  geom_sf(data = adour_edges_pawn_sf) +
  theme_light()
```


\


Users may want to combine different methods to detect neighbors. It's possible
by using for each method the function `create_edge_list()` and using the
function `append_edge_lists()` to merge all edges in a single list.


```{r 'create-edges-list-bishop'}
## Create edge list (Bishop method) ----
adour_edges_bishop <- create_edge_list(nodes    = nodes, 
                                       method   = "bishop", 
                                       degree   = 1, 
                                       directed = TRUE,
                                       reverse  = FALSE,
                                       self     = FALSE)

adour_edges_bishop

## Merge Pawn and Bishop edges ----
adour_edges <- append_edge_lists(adour_edges_pawn, adour_edges_bishop)

## Convert edges to spatial layer ----
adour_edges_sf <- edges_to_sf(adour_edges, nodes_sf)
```


\


```{r 'map-edges-list-pawn-bishop', fig.height=8, fig.width=6.5, echo=TRUE, fig.cap="Figure 8. Edges list (combined methods)", out.width='80%'}
## Map of nodes and edges ----
ggplot(nodes_sf) +
  geom_sf(size = 12) +
  geom_sf(data = adour_edges_sf) +
  theme_light()
```


\


## Connectivity matrix

From this edge list, we can build a **connectivity matrix**, i.e. a binary 
matrix of dimensions `n x n`, where `n` is the number of nodes (sampling units) 
indicating the presence (`1`) or the absence (`0`) of an edge (link) between pairs 
of nodes.

\

We can use the function `connectivity_matrix()` of the package `chessboard`.

```{r 'connectivity-matrix'}
## Create connectivity matrix ----
adour_matrix <- connectivity_matrix(adour_edges)

adour_matrix
```


\

The package `chessboard` provides a graphical function to visualize this matrix:
`gg_matrix()`.

```{r 'plot-connectivity-matrix', fig.height=8, fig.width=8, fig.cap="Figure 9. Connectivity matrix", out.width='80%'}
## Visualize connectivity matrix ----
gg_matrix(adour_matrix)
```


\

Optionally, we can use the function `matrix_to_edge_list()` to convert back the
connectivity matrix to edge list.

```{r 'connectivity-matrix-to-df'}
## Convert connectivity matrix to edge list ----
matrix_to_edge_list(adour_matrix)
```


\


## Nodes-by-edges matrix

The first object required by AEM is the **nodes-by-edges matrix**, i.e. a binary
matrix of dimensions `n x k`, where `n` is the number of nodes (in rows) and `k` the 
number of edges (in columns). This matrix represents the presence of a link 
influencing a site, directly or indirectly. It also gives the direction of the 
network.


\


The function `nodes_by_edges_matrix()` of the package `chessboard` is an alternative
to the function 
[`aem.build.binary()`](https://sdray.github.io/adespatial/reference/aem.build.binary.html) 
of the package [`adespatial`](https://cran.r-project.org/package=adespatial). 
This function creates the same output but works in a different way: it's only based on nodes 
labels (not on spatial coordinates). In addition, the function `nodes_by_edges_matrix()` 
adds labels to nodes and edges.



```{r 'nodes-by-edges-matrix'}
## Create nodes-by-edges matrix ----
adour_edges_mat <- nodes_by_edges_matrix(adour_edges)

## Content ----
names(adour_edges_mat)

## Header of the nodes-by-edges matrix ----
adour_edges_mat$"se.mat"[ , 1:15]

## Edges list ----
adour_edges_mat$"edges"
```

This function returns a list with the following elements:
  
  - `se.mat`: the nodes-by-edges matrix of dimensions `n x k`, where `n` is the 
number of nodes and `k` the number of edges (including the edge between the 
                                             fictitious origin and the first site);
- `edges`: a `data.frame` of edge list.


\


**Note:** a fictitious `origin` site (coded as `0`) has been created and represents
the first edge (coded as `E-01`) to the first site.


\


Let's plot our nodes-by-edges matrix.


```{r 'plot-nodes-by-edges-matrix', fig.height=4.5, fig.width=8, fig.cap="Figure 10. Nodes-by-edges matrix", out.width='80%'}
gg_matrix(adour_edges_mat$"se.mat")
```




\


## References

Blanchet F. G., Legendre P. & Borcard D. (2008) Modelling directional spatial 
processes in ecological data. **Ecological Modelling**, 215, 325-336. 
doi: [10.1016/j.ecolmodel.2008.04.001](https://doi.org/10.1016/j.ecolmodel.2008.04.001).

Dray S. _et al._ (2022) adespatial: Multivariate Multiscale Spatial Analysis. 
R package version 0.3-16, 
[https://CRAN.R-project.org/package=adespatial](https://CRAN.R-project.org/package=adespatial).
