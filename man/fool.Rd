% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fool.R
\name{fool}
\alias{fool}
\title{Find neighbors according to fool movement}
\usage{
fool(nodes, focus, degree = 1, directed = FALSE, reverse = FALSE, self = FALSE)
}
\arguments{
\item{nodes}{a \code{data.frame} with the following three columns:
\code{node}, \code{transect}, and \code{quadrats}. See \code{\link[=create_nodes_labels]{create_nodes_labels()}} for
further information.}

\item{focus}{an \code{character} of length 1. The node label for which the
neighbors must be found. Must exist in the \code{nodes} object.}

\item{degree}{an \code{integer} of length 1. The maximum number of neighbors to
search for in one direction.}

\item{directed}{a \code{logical} of length 1. If \code{FALSE} (default), search for
neighbors in both directions, i.e. at the left and at the right of the
focus node (undirected network). Otherwise (directed network) search for
neighbors at the right of the focus node (\code{reverse = FALSE}) or at the
left (\code{reverse = TRUE}).}

\item{reverse}{a \code{logical} of length 1. If \code{TRUE}, change the orientation of
the network. This argument is ignored if \code{directed = FALSE}.}

\item{self}{a \code{logical} of length 1. If \code{TRUE}, a node can be its own
neighbor. Default is \code{FALSE}.}
}
\value{
A subset of the \code{nodes} (\code{data.frame}) where each row is a neighbor
of \code{focus}.
}
\description{
For one node (argument \code{focus}), finds neighbors among a list of nodes
according to the fool movement.
This movement is derived from the chess game. The fool can move along one
direction, i.e. through a \strong{quadrats}, both from left to right and from
right to left (default behavior).

\strong{Important:} Use the function \code{\link[=create_nodes_labels]{create_nodes_labels()}} to create nodes
labels.

The detection of neighbors using the fool method can work with
two-dimensional sampling (both \strong{transects} and \strong{quadrats}) and
one-dimensional sampling of type \strong{transects}. For sampling of type
\strong{quadrats}, please use the function \code{\link[=pawn]{pawn()}}.

The identification of neighbors is only based on the nodes labels (no
explicit spatial detection). This means that labeling nodes is a
\strong{crucial step}.

The argument \code{degree} controls for the degree of neighborhood.
If \code{degree = 2}, four neighbors will be identified (except if
\code{directed = TRUE}): the two nodes at the left \strong{and} the two nodes at the
right of the focus node.

If \code{directed = TRUE} and \code{reverse = FALSE}, only the two nodes at the right
of the focus node will be considered as neighbors (directed network with
default orientation).

If \code{directed = TRUE} and \code{reverse = TRUE}, only the two nodes at the left
of the focus node will be considered as neighbors (directed network with
reverse orientation).
}
\note{
This function is called by \code{\link[=edges_list]{edges_list()}} (if \code{type = "fool"}). It can be
directly used only to 1) understand the neighbors detection method, 2) to
check, and 3) visualize detected neighbors for one particular node.
}
\examples{
library("bridge")

# Two-dimensional sampling ----
sites_infos <- expand.grid("transect" = 1:5, "quadrat" = 1:3)

nodes <- create_nodes_labels(transects = sites_infos$"transect", 
                             quadrats  = sites_infos$"quadrat")

fool(nodes, focus = "3-2", degree = 2)
fool(nodes, focus = "3-2", degree = 2, self = TRUE)
fool(nodes, focus = "3-2", degree = 2, directed = TRUE)
fool(nodes, focus = "3-2", degree = 2, directed = TRUE, reverse = TRUE)

# Visualization ----
focus     <- "3-2"
neighbors <- fool(nodes, focus = focus, degree = 1)

gg_chessboard(nodes) +
  geom_piece(nodes, focus) +
  geom_neighbors(neighbors)
  
# One-dimensional sampling (transects) ----
sites_infos <- 1:5
nodes <- create_nodes_labels(transects = sites_infos)

# Visualization ----
focus     <- "3-1"
neighbors <- fool(nodes, focus = focus, degree = 2, directed = TRUE)

gg_chessboard(nodes) +
  geom_piece(nodes, focus) +
  geom_neighbors(neighbors)
}
