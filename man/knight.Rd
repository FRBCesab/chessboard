% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/knight.R
\name{knight}
\alias{knight}
\title{Find neighbors according to knight movement}
\usage{
knight(
  nodes,
  focus,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
}
\arguments{
\item{nodes}{a \code{data.frame} with the following three columns:
\code{node}, \code{transect}, and \code{quadrats}. See \code{\link[=create_nodes_labels]{create_nodes_labels()}} for
further information.}

\item{focus}{an \code{character} of length 1. The node label for which the
neighbors must be found. Must exist in the \code{nodes} object.}

\item{degree}{an \code{integer} of length 1. The maximum number of neighbors to
search for in one direction.}

\item{directed}{a \code{logical} of length 1. If \code{FALSE} (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according the main direction of the system
(i.e. through quadrats).}

\item{reverse}{a \code{logical} of length 1. If \code{TRUE}, change the orientation of
the network (i.e. through quadrats). This argument is ignored if
\code{directed = FALSE}.}

\item{self}{a \code{logical} of length 1. If \code{TRUE}, a node can be its own
neighbor. Default is \code{FALSE}.}
}
\value{
A subset of the \code{nodes} (\code{data.frame}) where each row is a neighbor
of \code{focus}.
}
\description{
For one node (argument \code{focus}), finds neighbors among a list of nodes
according to the knight movement.
This movement is derived from the chess game. The knight is the difference
between the \code{\link[=wizard]{wizard()}} and the \code{\link[=queen]{queen()}}.

\strong{Important:} Use the function \code{\link[=create_nodes_labels]{create_nodes_labels()}} to create nodes
labels.

The detection of neighbors using the rook method can only work with
two-dimensional sampling (both \strong{transects} and \strong{quadrats}) and
one-dimensional sampling of type \strong{quadrats}. For sampling of type
\strong{transects} or \strong{quadrats}, please use the functions \code{\link[=fool]{fool()}} or
\code{\link[=pawn]{pawn()}}, respectively.

The identification of neighbors is only based on the nodes labels (no
explicit spatial detection). This means that labeling nodes is a
\strong{crucial step}.

The argument \code{degree} controls for the degree of neighborhood.
If \code{degree = 2}, 8 neighbors will be identified (except if
\code{directed = TRUE}). The knight must be used only if \code{degree > 1}.

If \code{directed = TRUE} and \code{reverse = FALSE}, only 4 nodes will be
considered as neighbors (remove the nodes at the bottom of the focus node).

If \code{directed = TRUE} and \code{reverse = TRUE}, only 4 nodes will be
considered as neighbors (remove the nodes at the top of the focus node).
}
\note{
This function is called by \code{\link[=edges_list]{edges_list()}} (if \code{type = "rook"}). It can be
directly used only to 1) understand the neighbors detection method, 2) to
check, and 3) visualize detected neighbors for one particular node.
}
\examples{
library("bridge")

# Two-dimensional sampling (only) ----
sites_infos <- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes <- create_nodes_labels(transects = sites_infos$"transect", 
                             quadrats  = sites_infos$"quadrat")

focus     <- "5-5"

# Default settings ----
neighbors <- knight(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_piece(nodes, focus) +
  geom_neighbors(neighbors)
  
# Directed (default orientation) ----
neighbors <- knight(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_piece(nodes, focus) +
  geom_neighbors(neighbors)
  
# Directed (reverse orientation) ----
neighbors <- knight(nodes, focus, degree = 3, directed = TRUE, 
                    reverse = TRUE)
gg_chessboard(nodes) +
  geom_piece(nodes, focus) +
  geom_neighbors(neighbors)
}
